%*******************************************************
% Bump Mapping
%*******************************************************
\section{Bump Mapping}

Bump mapping is enabled by setting a bump map to a \verb|GeometryNode|. This can
be done with the following Lua command:
\begin{lstlisting}
  set_bumpmap(<filename>)
\end{lstlisting}
This command sets the bump map on the \verb|PhongMaterial| attached to the
\verb|GeometryNode|.

Bump mapping is implemented in a similiar manner as texture mapping. For each
intersection point the $uv$ coordinates of that point are generated. The $uv$
coordinates are then used to index into the bump map and sample a value
using bilinear filtering. This value is then used in the calculations to
displace the surface normal and simulate bumps on the surface of a primitive.

In order to perform the bump mapping calculations, surface tangent vectors at
the point of intersection need to be generated. For this project, these tangent
vectors were only generated for the sphere, cube and plane primitives. Thus,
bump mapping is only supported for those aforementioned primitives.

The following subsections describe how the surface tangent vectors are generated
and the calculations to perform the displacement on the surface normal.

\subsection{Generating the Tangent Vectors}
A surface can be defined in terms of three bivariate functions:
\begin{equation}
\begin{split}
  x &= x(u, v) \\
  y &= y(u, v) \\
  z &= z(u, v) \\
\end{split}
\end{equation}
Taking the partial derivatives of these functions shall give us the tangent
vectors $\vec{P_{u}}$ and $\vec{P_{v}}$ \cite{1_blinn_1978}.

\subsubsection*{Sphere}
A point on the surface of the sphere can be defined in terms of the spherical
coordinates:
\begin{equation}
\begin{split}
  x &= rcos(\theta)sin(\theta) \\
  y &= -rcos(\phi) \\
  z &= -rsin(\theta)sin(\phi) \\
\end{split}
\end{equation}
Where $\theta$ and $\phi$ can be calculated as follows:
\begin{equation}
\begin{split}
  \theta &= atan(\frac{-Q_{z}}{Q_{x}}) \\
  \phi &= acos(\frac{-Q_{y}}{r})
\end{split}
\end{equation}
$Q$ is the intersection point and $r$ is the radius of the sphere.

Taking the partial derivatives of the bivariate functions, we have:
\begin{equation}
\begin{split}
  \vec{P_{u}} = \begin{bmatrix} -rsin(\theta)sin(\phi) & 0.0 & 
  -rcos(\theta)sin(\phi) \end{bmatrix}^{T} \\
  \vec{P_{v}} = \begin{bmatrix} rcos(\theta)cos(\phi) & rsin(\phi) &
  rsin(\theta)cos(\phi) \end{bmatrix}^{T}
\end{split}
\end{equation}

\subsubsection*{Cube \& Plane}
Generating the tangent vectors for the cube and plane both follow the exact same
algorithm. First the $\vec{P_{u}}$ tangent vector is generated from the surface 
normal at the intersection point using the method described in 
\cite{6_hughes_m√∂ller_2005}. Then $\vec{P_{v}}$ is generated by taking the 
cross product between the surface normal and $\vec{P_{u}}$.

\subsection{Calculating the Displacement Vector}
Once the tangent vectors and $uv$ coordinates are generated, they are used to
calculate the displacement vector, $\vec{D}$.

First the derivatives of the bump map at the specified texture coordinate is
calculated using the finite difference method:
\begin{equation}
\begin{split}
  f_{u} = \frac{(bumpmap(u + \epsilon, v) - bumpmap(u - \epsilon, v))}
  {2\epsilon} \\
  f_{v} = \frac{(bumpmap(u, v + \epsilon) - bumpmap(u, v + \epsilon))}
  {2\epsilon}
\end{split}
\end{equation}
Where $\epsilon$ is a very small number and $bumpmap$ is a function which
samples the bump map at the specified texture coordinate using bilinear
filtering. In the \verb|C++| code the \verb|std::numeric_limits::epsilon()| 
function is used as the $\epsilon$ value.

The displacement vector can now be calculated:
\begin{equation}
\begin{split}
  \vec{D} = \frac{f_{u}(\vec{N}\times\vec{P_{v}}) -
  f_{v}(\vec{N}\times\vec{P_{u}})}{||\vec{N}||}
\end{split}
\end{equation}
Where $\vec{N}$ is the surface normal.

Now the displacement vector can be added to the normal vector to produced the
new displaced normal vector which can then be used in the lighting calculations.

